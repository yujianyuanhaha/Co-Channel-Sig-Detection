clear all;
close all;

% create Signal of Interest(SoI)
% QPSK Mod + Pulse Shaping(RC)


opt = '';

Nb = 2000;  % num of bits
% xb = randi([0,1],[1,Nb]);
xb = sign(randn([1,Nb]));  % BPSK

% ======= QPSK(offset) Mod ============================
% Ns = Nb/2; % num of symbol
% M = 4;
% y1 = zeros(1,Nb/2);
% for k = 1:Ns
%     d = 2^xb(2*k-1) + xb(2*k);
%     y1(k) = exp(1j*(2*pi*d/M + pi/4));   % offset
% end

x_mod = xb;

% ========= pulse shape (RC Raised Cosine)  ============================
sps = 4; % sample per symbol
span = 4; % duration
beta = 0.25;
shape = 'sqrt';
p = rcosdesign(beta,span,sps,shape);
rCosSpec =  fdesign.pulseshaping(sps,'Raised Cosine',...
    'Nsym,Beta',span,0.25);
rCosFlt = design ( rCosSpec );
rCosFlt.Numerator = rCosFlt.Numerator / max(rCosFlt.Numerator);
% upsample
upsampled = upsample ( x_mod , sps);
FltDelay = (span*sps)/2;  % shift
temp = filter (rCosFlt , [ upsampled , zeros(1,FltDelay) ] );
x_ps = temp( 9:end); % to be fixed



% ==== single carrier upgrade ================================
% complex envelop
% fc = 1200;
% wc = 2*pi*fc; % carrier frequency
fs = 10000;  % sample rate
dt = 1/fs;  %  min time step duration - todo
t  = 1:Nb*sps;
% x_up = x_ps .* cos(wc*t*dt) ;


% ===== additive nbi signal (on the channel) ====
f_nbi = 750;
w_nbi = 2*pi*f_nbi;  %
A_nbi = 10.0;
phi_nbi = 0.4*pi;
nbi = A_nbi * cos(w_nbi*t*dt + phi_nbi);


% noise
std = 0.10;
n = std * randn(1, Nb*sps);

% received signal
rx = x_ps + nbi + n;

% plot
% figure;
% plot(abs(fftshift(fft(x_up))));
% figure;
% plot(abs(fftshift(fft(rx))));

% downgrade 
% x_down = 2 * demod(x_up,fc,fs);


% match filter - BUGS to be fixed
% R = conv(rx,p);
% R = R(18:end);

% downsample for pulse shape
% x_ds = downsample(R, sps);

x_ds = downsample(rx, sps);



if opt == 'fftThr'
    % === method 1: fft threshold
    threshold = max(abs(fft(x_ps)));
    x_end = fftThr(x_ds, threshold);
elseif opt == 'trainNF'
    % === method 2: trained notch filter
    
elseif opt == 'kayEst'
    % === method 3: Kay
    f_h = kayEst(x_ds,fs);
    X = fft(x_ds);
    X(f_h/fs*length(x_ds)/2) = 0; % assign zero
    x_end = ifft(X);
else
    disp('wrong opt, choose among fftThr,trainNF,kayEst');
end










% LIMITATION: 1. low resolution, min 10Hz 2. single tone 3. high SNR



% == todo demodulate ==

x_h = sign(x_end);
BER = sum(xb ~= x_h)/Nb




% == metric: bit error rate ===





